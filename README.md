A Program to Detect Recombinants From Unaligned Sequences
-----------------------

### About
This program is a novel approach for detecting recombinant sequences and corresponding statistical support values from unaligned biological sequences. This framework develops on the basis of the paritial alignment results from jumping hidden markov model (JHMM, or mosaic), after that, by dividing them into multiple equal-length triples, on which we use a new distance-based procedure to identify recombinant from each triple. Statistical support values calculated from Bootstrap, the bigger the better, indicating the robustness of identified recombinants.


### Required softwares
- MAFFT used to align one sequence to another two pre_aligned sequences (https://mafft.cbrc.jp/alignment/software/)
- SeqKit used to concatenate the two segments for each triple (https://bioinf.shenwei.me/seqkit/download/)
- Python \\
-- Require modules for Python 2 user:
-- Require modules for Python 3 user:

### Optional softwares (only used for simulation section)
- Msprime used to generate one arbitrary phylogenetic tree (https://msprime.readthedocs.io/en/stable/installation.html)
- Snakemake
- INDELible
- Python module  

### Required Input Files 
- Patial alignment produced by JHMM (please see [MZmosaic](https://github.com/qianfeng2/detREC_program/tree/master/MZmosaic) folder)
- Input fasta format biological sequences, maximum length for identifiers length is 15 (Zilversmit et al., 2013)

### Creating Input File

### Run Example 

```
cd /Users/fengqian/MZmosaic
./mosaic -estimate -seq input.fasta  -rec 0 -aa -tag middle_file
delta=$(grep -o 'Gap initiation: .*$' middle_file_align.txt | cut -c17-)
epsl=$(grep -o 'Gap extension:  .*$' middle_file_align.txt | cut -c17-)
./mosaic -seq input.txt -del $delta -eps $epsl -aa -tag output -grid 0.001 0.010 10 1
```

### Run Example for large number of sequences (>10000 sequences)

Instead of complete and time-consuming Baum-Welch algorithm to estimate gap open and gap extension probabilities, the slightly less accurate but much faster viterbi training algorithm has been used. Each iteration was run as on a high performing computing cluster (Helix)

Iterate until convergence:

1) Choose an initial set of parameters
2) Compute the Viterbi paths of all sequences
3) Count frequencies of events and calculate new parameters
4) Update -> 1) 
5) Stop when the major parameters del and eps change by less than 1%.

The empirical Ghana pilot DBLa dataset analyzed in manuscript contain more than 17000 sequences, the detailed code for generating partial alignment results are displayed in Empirical_script(a) sub folder.


### Running Meltos
#### Required:
- "-svFile \<filename\>": name of the file which contains your preprepared SV information.
- "-treeFile \<filename\>": name of the file which contains your premade SSNV lineage tree.
- "-ssnvFile \<filename\>": name of the file which contains your list of SSNVs that were used in your input lineage tree.
- "-numSamples \<integer\>": count of the number of spatially distinct samples in your sv and ssnv files.

#### Optional:
 - "-outputFile \<filename\>": the prefix you want for your outputfiles. If not specified, defaults to the name of your sv file +".meltos"
  NOTE: This will overwrite files with the same name. This prefix should include the directory in which you want the files to go.

 - "-sweep": have meltos run a series of  tests with combinations of different parameters.

 - "-min \<arg\>":   Set an upper bound for an abscence in a sample.

 - "-max \<arg\>":   Set a lower bound for presence in a sample.

 - "-clus \<arg\>":  Set a max difference in VAF allowed for combining variant clusters.

 - "-err \<arg\>":   Set how lenient to be with phylogenic constraints.



### Output
Produces a series of files based on various combinations of parameters, and places them in the directory specified by output.
The file starts with parameter specifications used to create the file.
- Lineage Tree Node Assignments
After that comes VAF calculations and SV assignments for nodes in the lineage tree. Nodes from the original lineage tree will share the same index from the first file, and new nodes will be labeled sequentially after that.
The SV assignments will also share their indices with the indices of the SVs from their original input file. SSNVs are not shown in this output. Node 0 is the root node, and is not from the original lineage tree.
- SVs Assigned to Added New SV Nodes:
A repeat of information from the SV assignments, but only showing nodes that were generated by the algorithm, rather than nodes that originally came from the input tree.
- SVs Assigned to Inviable New SV Nodes:
A list of nodes that were created by the algorithm but were unable to be placed into the lineage tree, together with the indices of their SV assignments.

Finally, the tree's edges are displayed, with the index of the parent node on the left, and the index of the child node on the right.

### Run Example

```
python integrated_rec_det.py output_align.txt input.fasta output.csv
```

### Reference
- Martine M Zilversmit et al. "Hypervariable antigen genes in malaria have ancient roots". In: BMC evolutionary biology 13.1 (2013), p. 110.
- bb
